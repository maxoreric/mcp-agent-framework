# MCP Agent Framework - Python Implementation

## Project Overview

The MCP Agent Framework is a Python-based system for creating, orchestrating, and managing networks of AI agents. Using the Model Context Protocol (MCP) as the standard communication protocol, this framework allows agents to dynamically create subordinate agents, forming tree-like organizational structures to solve complex problems.

This MVP version focuses on core functionalities, runs in a terminal environment, and prioritizes support for OpenAI-compatible APIs.

## Core Concepts

### Agent Model

- **MCP Host Architecture**: Each agent functions as an independent MCP host application containing:
  - LLM Client: Handles interactions with language model APIs
  - MCP Server: Exposes the agent's capabilities as tools for other agents
  - MCP Client: Calls other agents' MCP services

- **Agent Templates (Prefab Pattern)**:
  - Base agent template that can be instantiated as needed
  - Each instance can be configured for specific roles (CEO, expert agent, etc.)
  - All instances share core logic but have different expertise and responsibilities
  - Instances can be destroyed after task completion to free resources

### Organizational Structure

- **Main Agent (CEO)**: The only instance that directly interacts with users
- **Expert Agents**: Domain-specific agents created by the main agent or other superior agents
- **Hierarchical Structure**: Agents can create subordinate agents via MCP tool calls
- **Lifecycle Management**: Agents are destroyed after task completion to release resources

### XML-Style Communication

- Structured information passed using single-layer XML-style tags
- Standardized format for different content types
- Easily understood and generated by LLMs

Main tag types:
```xml
<role>Agent role description</role>
<task>Task description</task>
<context>Context information</context>
<result>Task result</result>
<error>Error information</error>
```

### Task Orchestration

- Dynamic maintenance of task dependency trees
- Tracking of task status and completion
- Terminal visualization of task progress
- Task scheduling based on dependency relationships

## Technology Stack

- **Language**: Python 3.9+
- **MCP Implementation**: Custom Python implementation of the Model Context Protocol
- **LLM Client**: Support for OpenAI-compatible APIs
- **XML Processing**: Python's built-in XML libraries (xml.etree.ElementTree)
- **Async Operations**: Python's asyncio library
- **CLI**: Rich library for terminal interfaces
- **Testing**: Pytest for unit and integration testing

## Development Methodology

We will follow an agile development approach with:

1. **Iterative Development**: Each iteration will deliver a working MVP with incremental improvements
2. **Test-Driven Development**: Tests will be written before or alongside the implementation
3. **Continuous Integration**: Automated testing with each commit
4. **Regular Reviews**: Code reviews and retrospectives after each iteration
5. **Flexible Planning**: Adjust scope and priorities based on progress and feedback

## Iteration Planning

### Iteration 1: Core Framework Setup (1 week)

**Goal**: Establish the project structure and core interfaces.

**Tasks**:
1. Create the Python project structure
2. Define core interfaces and abstract classes for:
   - Agent
   - Task
   - MCP Communication
3. Implement basic XML protocol handler
4. Set up testing infrastructure
5. Create configuration management system

**Deliverable**: Working project skeleton with interface definitions and basic tests.

```python
# Example: Agent interface
class Agent(ABC):
    """Base interface for all agents in the system."""
    
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize the agent."""
        pass
        
    @abstractmethod
    async def submit_task(self, task: Task) -> TaskResult:
        """Submit a task to this agent."""
        pass
        
    @abstractmethod
    async def create_child_agent(self, spec: AgentSpec) -> Agent:
        """Create a subordinate agent."""
        pass
```

### Iteration 2: LLM Integration (1 week)

**Goal**: Implement communication with language models.

**Tasks**:
1. Develop OpenAI-compatible API client
2. Create prompt management system
3. Implement response parsing
4. Add error handling and retry mechanisms
5. Set up API key and configuration management

**Deliverable**: Functional LLM client that can send requests and parse responses.

```python
# Example: OpenAI-compatible client
class OpenAICompatibleClient:
    """Client for interacting with OpenAI-compatible APIs."""
    
    def __init__(self, config: Dict[str, Any]):
        self.api_key = config.get("api_key")
        self.base_url = config.get("base_url", "https://api.openai.com/v1")
        self.model = config.get("model", "gpt-4-turbo")
        
    async def generate_completion(self, prompt: str, **options) -> str:
        """Generate text completion."""
        # Implementation for API call
        
    async def generate_chat(self, messages: List[Dict[str, str]], **options) -> Dict[str, str]:
        """Generate chat completion."""
        # Implementation for chat API call
```

### Iteration 3: Agent System (2 weeks)

**Goal**: Implement the agent system with basic functionality.

**Tasks**:
1. Develop the agent factory for creating different types of agents
2. Implement agent registry for tracking active agents
3. Create the base agent implementation
4. Implement agent communication using MCP principles
5. Add agent lifecycle management

**Deliverable**: Working agent system that can create and manage agents.

```python
# Example: Agent factory
class AgentFactory:
    """Factory for creating agent instances."""
    
    def __init__(self, registry: AgentRegistry, config: Dict[str, Any]):
        self.registry = registry
        self.config = config
        
    async def create_agent(self, spec: AgentSpec, parent: Optional[Agent] = None) -> Agent:
        """Create a new agent based on specification."""
        agent_id = str(uuid.uuid4())
        agent = AgentImpl(agent_id, spec.role, self.config, parent)
        
        # Register agent
        self.registry.register_agent(agent)
        
        # Initialize
        await agent.initialize()
        
        # Establish parent-child relationship
        if parent:
            parent.add_child(agent)
            
        return agent
```

### Iteration 4: Task Management (2 weeks)

**Goal**: Implement the task orchestration system.

**Tasks**:
1. Develop the task data model
2. Implement task scheduler
3. Create task tree for dependency tracking
4. Add task execution and result handling
5. Implement task status visualization

**Deliverable**: Working task system that can handle dependencies and scheduling.

```python
# Example: Task scheduler
class TaskScheduler:
    """Schedules and manages task execution."""
    
    def __init__(self, task_tree: TaskTree, config: Dict[str, Any]):
        self.task_tree = task_tree
        self.executors = {}
        self.max_concurrent = config.get("max_concurrent", 5)
        self.queue = asyncio.Queue()
        
    async def submit_task(self, task: Task) -> None:
        """Submit a task for scheduling."""
        # Add to task tree
        self.task_tree.add_task(task)
        
        # Check dependencies
        if self._check_dependencies(task):
            await self._schedule_task(task)
            
    def _check_dependencies(self, task: Task) -> bool:
        """Check if all dependencies are met."""
        return all(
            dep_task and dep_task.status == TaskStatus.COMPLETED
            for dep_id in task.dependencies
            if (dep_task := self.task_tree.get_task(dep_id))
        )
```

### Iteration 5: Multi-agent Orchestration (2 weeks)

**Goal**: Enable agents to collaborate effectively.

**Tasks**:
1. Implement parent-child agent communication
2. Develop agent tool registration and discovery
3. Create mechanisms for delegating tasks to child agents
4. Implement result aggregation from multiple agents
5. Add advanced task decomposition

**Deliverable**: Working multi-agent system with collaboration capabilities.

```python
# Example: MCP server implementation
class McpServer:
    """Server component for the Model Context Protocol."""
    
    def __init__(self, name: str, version: str = "1.0.0"):
        self.name = name
        self.version = version
        self.tools = {}
        
    def register_tool(self, name: str, schema: Dict[str, Any], handler: Callable) -> None:
        """Register a tool that can be called by clients."""
        self.tools[name] = {
            "schema": schema,
            "handler": handler
        }
        
    async def handle_call(self, tool_name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle an incoming tool call."""
        if tool_name not in self.tools:
            raise ValueError(f"Tool {tool_name} not found")
            
        tool = self.tools[tool_name]
        # Validate params against schema
        # Execute handler
        return await tool["handler"](params)
```

### Iteration 6: CLI Interface (1 week)

**Goal**: Create a user-friendly command-line interface.

**Tasks**:
1. Implement the command-line interface using Rich
2. Develop input handling and history
3. Create formatted output for agent responses
4. Add progress indicators for long-running tasks
5. Implement task tree visualization

**Deliverable**: Functional CLI that users can interact with.

```python
# Example: CLI implementation
class CommandLineInterface:
    """Command-line interface for the agent framework."""
    
    def __init__(self, main_agent: Agent):
        self.main_agent = main_agent
        self.console = Console()
        
    async def start(self) -> None:
        """Start the CLI interface."""
        self.console.print("[bold green]MCP Agent Framework CLI[/bold green]")
        self.console.print("Type your query or 'exit' to quit")
        
        while True:
            query = await self._get_input()
            
            if query.lower() == "exit":
                await self._shutdown()
                break
                
            try:
                with Progress() as progress:
                    task_id = progress.add_task("Processing your request...", total=100)
                    
                    # Create task
                    task = Task(
                        id=str(uuid.uuid4()),
                        description=query,
                        status=TaskStatus.PENDING,
                        dependencies=[],
                        assigned_to=self.main_agent.id
                    )
                    
                    # Submit task to main agent
                    result = await self.main_agent.submit_task(task)
                    
                    # Display result
                    self.console.print("\n[bold green]Result:[/bold green]")
                    self.console.print(result.content)
                    
                    # Display task tree
                    self._display_task_tree()
            except Exception as e:
                self.console.print(f"[bold red]Error:[/bold red] {str(e)}")
```

### Iteration 7: Example Applications & Refinement (2 weeks)

**Goal**: Create working examples and refine the system based on feedback.

**Tasks**:
1. Implement the coding assistant example
2. Create the research assistant example
3. Optimize performance and resource usage
4. Enhance error handling and recovery
5. Improve documentation and examples

**Deliverable**: Complete MVP with working examples and documentation.

## Project Structure

```
📦 mcp_agent_framework
 ┣ 📂 mcp_agent_framework         # Main package
 ┃ ┣ 📂 core                     # Core interfaces and infrastructure
 ┃ ┃ ┣ 📜 agent.py               # Agent interfaces
 ┃ ┃ ┣ 📜 task.py                # Task interfaces
 ┃ ┃ ┣ 📜 config.py              # Configuration management
 ┃ ┃ ┗ 📜 exceptions.py          # Custom exceptions
 ┃ ┣ 📂 agents                   # Agent implementations
 ┃ ┃ ┣ 📜 agent_impl.py          # Base agent implementation
 ┃ ┃ ┣ 📜 agent_factory.py       # Agent creation
 ┃ ┃ ┗ 📜 agent_registry.py      # Agent tracking
 ┃ ┣ 📂 task                     # Task management
 ┃ ┃ ┣ 📜 scheduler.py           # Task scheduler
 ┃ ┃ ┣ 📜 executor.py            # Task execution
 ┃ ┃ ┗ 📜 task_tree.py           # Dependency management
 ┃ ┣ 📂 llm                      # LLM integration
 ┃ ┃ ┣ 📜 client.py              # Generic client interface
 ┃ ┃ ┣ 📜 openai.py              # OpenAI-compatible client
 ┃ ┃ ┗ 📜 prompt_manager.py      # Prompt templates
 ┃ ┣ 📂 mcp                      # MCP implementation
 ┃ ┃ ┣ 📜 server.py              # MCP server
 ┃ ┃ ┣ 📜 client.py              # MCP client
 ┃ ┃ ┗ 📜 xml_protocol.py        # XML message handling
 ┃ ┣ 📂 cli                      # CLI interface
 ┃ ┃ ┣ 📜 main.py                # Main CLI entry point
 ┃ ┃ ┣ 📜 visualization.py       # Terminal visualizations
 ┃ ┃ ┗ 📜 input_handler.py       # User input processing
 ┃ ┗ 📂 utils                    # Utilities
 ┃   ┣ 📜 logging.py             # Logging utilities
 ┃   ┣ 📜 async_utils.py         # Async helpers
 ┃   ┗ 📜 xml_utils.py           # XML helper functions
 ┣ 📂 examples                   # Example applications
 ┃ ┣ 📜 coding_assistant.py      # Coding assistant example
 ┃ ┗ 📜 research_assistant.py    # Research assistant example
 ┣ 📂 tests                      # Test suite
 ┃ ┣ 📂 unit                     # Unit tests
 ┃ ┣ 📂 integration              # Integration tests
 ┃ ┗ 📂 e2e                      # End-to-end tests
 ┣ 📜 setup.py                   # Package setup
 ┣ 📜 requirements.txt           # Dependencies
 ┣ 📜 README.md                  # Project documentation
 ┗ 📜 LICENSE                    # License information
```

## Testing Strategy

1. **Unit Tests**: Test individual components in isolation
   - Agent creation and lifecycle
   - Task management
   - XML protocol handling
   - LLM client operations

2. **Integration Tests**: Test component interactions
   - Agent communication
   - Task orchestration
   - LLM integration

3. **End-to-End Tests**: Test complete workflows
   - Simple coding tasks
   - Research scenarios
   - Error handling and recovery

4. **Continuous Integration**: Automated testing with GitHub Actions
   - Run tests on each commit
   - Enforce code quality standards
   - Generate test coverage reports

## Implementation Guidelines

### Code Style and Standards

- Follow PEP 8 style guidelines
- Use type annotations for better IDE support
- Document all public interfaces with docstrings
- Use meaningful variable and function names

### Error Handling

- Use custom exception classes for specific error scenarios
- Implement proper async error handling with try/except/finally
- Provide informative error messages
- Add logging at appropriate levels

### Performance Considerations

- Use async/await for I/O operations
- Implement resource pooling for LLM clients
- Monitor and limit concurrent operations
- Implement timeouts for external API calls

### Security

- Secure API key storage
- Input validation for all external inputs
- Limit agent permissions to necessary operations
- Implement proper error handling to prevent information leakage

## Next Steps

1. Create the GitHub repository structure
2. Set up initial project with requirements and documentation
3. Implement core interfaces (Agent, Task)
4. Begin work on the XML protocol handler
5. Set up testing infrastructure
6. Start implementing the LLM client

By following this iterative development plan, we will build the MCP Agent Framework in a structured, manageable way, with each iteration delivering a working product that we can test and refine.
